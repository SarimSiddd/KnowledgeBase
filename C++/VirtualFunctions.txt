#include <string>
class Animal
{
protected:
std::string m_strName;
// We're making this constructor protected because
// we don't want people creating Animal objects directly,
// but we still want derived classes to be able to use it.
Animal(std::string strName)
: m_strName(strName)
{
}
public:
std::string GetName() { return m_strName; }
virtual const char* Speak() { return "???"; }
};
class Cat: public Animal
{
public:
Cat(std::string strName)
: Animal(strName)
{
}
virtual const char* Speak() { return "Meow"; }
};


Only the most base
class function needs to be tagged as virtual for all of the derived functions to work virtually.



If the return type of a virtual function
is a pointer or a reference to a class, override functions can return a pointer or a reference to a
derived class. These are called covariant return types. Here is an example:

class Base
{
public:
// This version of GetThis() returns a pointer to a Base class
virtual Base* GetThis() { return this; }
};
class Derived: public Base
{
// Normally override functions have to return objects of the same type
as the base function
// However, because Derived is derived from Base, it's okay to return
Derived* instead of Base*
virtual Derived* GetThis() { return this; }
};